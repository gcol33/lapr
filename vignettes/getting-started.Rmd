---
title: "Getting Started with couplr"
author: "Gilles Colling"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Getting Started with couplr}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 6,
  fig.height = 4
)
library(couplr)
```

## Overview

The linear assignment problem (LAP) is a fundamental optimization problem: given a cost matrix where entry (i, j) represents the cost of assigning source i to target j, find the one-to-one assignment that minimizes (or maximizes) total cost. LAP appears throughout data science, operations research, and scientific computing -- from scheduling and resource allocation to computer vision and bioinformatics.
`couplr` provides efficient LAP solvers with a tidy interface that integrates naturally with modern R workflows.

### Why couplr?

While other R packages address LAP, `couplr` distinguishes itself through:

- **Tidy integration**: First-class support for tibbles, dplyr workflows, and grouped data
- **Algorithm selection**: 12+ algorithms with automatic selection based on problem characteristics
- **Production matching**: High-level matching functions for observational studies (v1.0.0)
- **Scalability**: From small matrices to thousands of parallel problems

**Alternative packages** and how they differ:

- `clue`: General-purpose optimization toolkit where LAP is one feature among many
- `lpSolve`: Broad linear programming focus, less specialized for assignment
- `RcppHungarian`: Single algorithm implementation without tidy interface

`couplr` focuses specifically on assignment problems with a user-friendly API and modern R idioms.

### Who This Vignette Is For

**Audience**: Beginners to couplr, R users familiar with basic matrix operations

**Prerequisites**:

- Basic R knowledge (data frames, functions)
- Understanding of what a "cost" or "distance" matrix means

**What You'll Learn**:

- How to solve basic assignment problems with `lap_solve()`
- Working with data frames, rectangular problems, and forbidden assignments
- Batch solving and finding multiple solutions
- When to use different algorithms

**Time to complete**: 20-30 minutes

### Documentation Roadmap

The couplr documentation is organized as follows:

| Vignette | Focus | Difficulty |
|----------|-------|------------|
| **Getting Started** | Basic LAP solving, API introduction | Beginner |
| Algorithms | Mathematical foundations, solver selection | Intermediate |
| Matching Workflows | Production matching pipelines | Intermediate |
| Pixel Morphing | Scientific applications, approximations | Advanced |

*You are here: Getting Started*

### Key Features

- **Tidy interface**: Works with data frames, tibbles, and grouped data
- **Efficient**: Implements multiple algorithms with automatic selection
- **Flexible inputs**: Handles matrices, data frames, rectangular problems, and forbidden assignments
- **Batch processing**: Solve thousands of problems efficiently with optional parallelization
- **K-best solutions**: Find multiple near-optimal solutions using Murty's algorithm

## Installation

```{r eval=FALSE}
# Install from CRAN
install.packages("couplr")

# Or install development version from GitHub
# install.packages("remotes")
remotes::install_github("gcol33/couplr")
```

## The Assignment Problem

### Problem Definition

Consider assigning nurses to shifts in a hospital. Each nurse has different suitability for each shift based on skills, travel time, and overtime likelihood. The assignment problem finds the optimal one-to-one matching that minimizes total cost (or maximizes total preference).

This vignette uses a recurring **hospital staff scheduling** example that demonstrates increasingly complex scenarios. The same conceptual problem -- assigning nurses to shifts -- evolves to show different couplr features.

**Simple Example**: Three nurses can cover three shifts with the following costs (lower = better fit):

|         | Shift 1 | Shift 2 | Shift 3 |
|---------|---------|---------|---------|
| Nurse 1 |   4     |   2     |   5     |
| Nurse 2 |   3     |   3     |   6     |
| Nurse 3 |   7     |   5     |   4     |

The optimal assignment is: Nurse 1 → Shift 2 (cost 2), Nurse 2 → Shift 1 (cost 3), Nurse 3 → Shift 3 (cost 4), for a total cost of 9.

> **Note**: couplr includes a comprehensive `hospital_staff` dataset that we'll use throughout this vignette. Type `?hospital_staff` for details.

## Basic Usage

### Matrix Input

The simplest way to use `couplr` is with a numeric cost matrix:

```{r basic-matrix}
# Cost matrix: 3 nurses × 3 shifts (from our simple example above)
cost <- matrix(c(
  4, 2, 5,  # Nurse 1 costs for shifts 1, 2, 3
  3, 3, 6,  # Nurse 2 costs
  7, 5, 4   # Nurse 3 costs
), nrow = 3, byrow = TRUE)

# Solve the assignment problem
result <- lap_solve(cost)
print(result)
```

The result is a tidy tibble showing which source (nurse) is assigned to which target (shift), along with individual and total costs.

**Reading the output**: Row 1 shows Nurse 1 assigned to Shift 2 with cost 2. The `total_cost` column shows the cumulative cost of all assignments (9).

For larger problems, use the built-in `hospital_staff` dataset:

```{r hospital-matrix}
# 10 nurses × 10 shifts
result_10x10 <- lap_solve(hospital_staff$basic_costs)
head(result_10x10)

# Total cost
cat("Total assignment cost:", get_total_cost(result_10x10), "\n")
```

### Data Frame Input

For more complex workflows, especially when working with existing data pipelines, use data frames:

```{r df-input}
library(dplyr)

# The hospital_staff dataset includes a data frame version
head(hospital_staff$schedule_df)

# Solve using column names
result <- lap_solve(hospital_staff$schedule_df, nurse_id, shift_id, cost)
print(result)
```

This approach is particularly useful when your data is already in long format, when pulling from databases, or when integrating with dplyr workflows.

---

*Now that we can solve the basic problem, what happens when we have more shifts than nurses to fill them?*

## Working with Rectangular Problems

Real scheduling problems rarely have equal numbers of nurses and shifts. A hospital might have 8 nurses available but need to cover 12 shifts, or have 15 nurses but only 10 shifts to fill.

Unlike many assignment solvers, `couplr` handles rectangular problems (unequal numbers of sources and targets) without manual padding:

```{r rectangular}
# 3 nurses, 5 available shifts - assign each nurse to one shift
cost_rect <- matrix(c(
  1, 2, 3, 4, 5,   # Nurse 1's costs for 5 shifts
  6, 5, 4, 3, 2,   # Nurse 2's costs
  2, 3, 4, 5, 6    # Nurse 3's costs
), nrow = 3, byrow = TRUE)

result <- lap_solve(cost_rect)
print(result)
```

The solver automatically handles the rectangular structure, assigning each of the 3 nurses to their best available shift among the 5 options. Notice that shifts 3 and 4 remain unassigned (they're not in the `target` column).

**Interpretation**: When rows < columns, each row (nurse) gets exactly one column (shift), and some columns remain unassigned. When rows > columns, the matrix is transposed internally so each column gets one row.

---

*What if certain nurse-shift combinations are impossible due to scheduling conflicts or skill requirements?*

## Forbidden Assignments

In real scheduling, some assignments are simply impossible: a nurse lacks the required certification for an ICU shift, or has a scheduling conflict that makes a night shift impossible.

Use `NA` or `Inf` to mark impossible or forbidden assignments:

```{r forbidden}
# Fresh cost matrix
cost <- matrix(c(
  4, 2, 5,
  3, 3, 6,
  7, 5, 4
), nrow = 3, byrow = TRUE)

# Nurse 1 cannot work Shift 3 (lacks ICU certification)
cost[1, 3] <- NA

# Nurse 2 cannot work Shift 1 (scheduling conflict)
cost[2, 1] <- Inf

result <- lap_solve(cost)
print(result)
```

The solver respects these constraints and finds the optimal assignment among the feasible options. Compare this result to the unconstrained solution: Nurse 1 still gets Shift 2 (cost 2), but the other assignments adjust around the constraints.

**When to use `NA` vs `Inf`**: Both mark forbidden assignments. Use `NA` for "not applicable" (e.g., skill mismatch) and `Inf` for "infinitely costly" (e.g., severe overtime). Functionally they behave identically.

---

*So far we've minimized costs. What about maximizing preferences instead?*

## Maximization Problems

Sometimes you want to maximize preferences rather than minimize costs. Nurses have shift preferences (higher = more preferred), and happier nurses mean lower turnover.

Switch to maximization by setting `maximize = TRUE`:

```{r maximize}
# Preference matrix from hospital_staff (0-10 scale, higher = more preferred)
head(hospital_staff$preferences)

# Maximize total nurse satisfaction
result <- lap_solve(hospital_staff$preferences, maximize = TRUE)
head(result)

cat("\nTotal preference score:", get_total_cost(result), "\n")
```

**Behind the scenes**: `maximize = TRUE` internally negates the costs, solves the minimization problem, then reports results on the original scale.

---

*What if you need to schedule multiple days at once, each with its own cost matrix?*

## Grouped Data Frames

One of `couplr`'s most powerful features is seamless integration with grouped data frames, allowing you to solve many related problems at once.

The `hospital_staff$weekly_df` dataset contains scheduling costs for 5 days. Each day needs its own optimal assignment:

```{r grouped}
# Weekly schedule: 5 days × 10 nurses × 10 shifts
head(hospital_staff$weekly_df)

# Solve all days at once
weekly_results <- hospital_staff$weekly_df |>
  group_by(day) |>
  lap_solve(nurse_id, shift_id, cost)

# View assignments by day
weekly_results |>
  group_by(day) |>
  summarise(total_cost = sum(cost), .groups = "drop")
```

This pattern---grouping, then solving---works naturally with dplyr pipelines and is much cleaner than writing loops.

## Batch Solving

---

*For even larger scale---hundreds or thousands of independent problems---grouped data frames may become unwieldy. That's where batch solving shines.*

For maximum efficiency when solving many independent problems, use `lap_solve_batch()`:

```{r batch}
# Create list of cost matrices
set.seed(123)
cost_list <- lapply(1:100, function(i) matrix(runif(9, 1, 10), 3, 3))

# Solve all problems at once
batch_results <- lap_solve_batch(cost_list)

# View summary statistics
batch_results |>
  distinct(problem_id, total_cost) |>
  summarise(
    n_problems = n(),
    mean_cost = mean(total_cost),
    min_cost = min(total_cost),
    max_cost = max(total_cost)
  )
```

### Parallel Batch Solving

For large numbers of problems, enable parallel processing:

```{r parallel, eval=FALSE}
# Solve with 4 threads
batch_results <- lap_solve_batch(cost_list, n_threads = 4)

# Use all available cores
batch_results <- lap_solve_batch(cost_list, n_threads = NULL)
```

## Finding Multiple Solutions

---

*The optimal schedule might be mathematically perfect but practically impossible---Nurse 1 is on vacation that week. What are the alternatives?*

Sometimes you want to explore alternative near-optimal solutions. Use `lap_solve_kbest()` to find the k best solutions:

```{r kbest}
cost <- matrix(c(
  1, 2, 3,
  4, 3, 2,
  5, 4, 1
), nrow = 3, byrow = TRUE)

# Find top 5 solutions
kbest <- lap_solve_kbest(cost, k = 5)
print(kbest)

# Get summary of solutions
summary(kbest)
```

This is useful for:

- Exploring alternative plans when the optimal solution is infeasible in practice
- Robustness analysis
- Understanding the cost landscape around the optimum

## Extracting and Working with Results

`couplr` provides several utility functions for working with results:

```{r utilities}
result <- lap_solve(cost)

# Extract total cost
get_total_cost(result)

# Get algorithm used
get_method_used(result)

# Convert to binary assignment matrix
as_assignment_matrix(result)

# Check result type
is_lap_solve_result(result)
```

## Algorithm Selection

---

*By default, couplr chooses an algorithm automatically. But understanding the options can help with performance tuning or debugging.*

`couplr` includes multiple algorithms optimized for different scenarios. The default `"auto"` method automatically selects the best algorithm:

```{r methods}
# Let couplr choose (default)
lap_solve(cost, method = "auto")

# Force specific algorithm:
lap_solve(cost, method = "jv")         # Jonker-Volgenant (general purpose)
lap_solve(cost, method = "hungarian")  # Hungarian algorithm
lap_solve(cost, method = "auction")    # Auction algorithm
lap_solve(cost, method = "sap")        # Sparse assignment (for sparse problems)
```

### Auction Algorithm Variants

The auction algorithm has multiple variants for different problem characteristics:

```{r auction-variants, eval=FALSE}
# Standard fixed-epsilon auction (default)
lap_solve(cost, method = "auction")

# Scaled-epsilon auction with epsilon-scaling phases
# Better for problems with large cost ranges
lap_solve(cost, method = "auction_scaled")

# Gauss-Seidel auction with sequential bidding
# Can be faster for certain problem structures
lap_solve(cost, method = "auction_gs")
```

### Binary Cost Problems

For problems where all costs are 0 or 1, use the specialized HK01 algorithm:

```{r hk01-example}
# Create binary cost matrix
binary_cost <- matrix(sample(0:1, 9, replace = TRUE), 3, 3)

# Specialized algorithm for binary costs
lap_solve(binary_cost, method = "hk01")
```

The `"auto"` method selects algorithms based on problem characteristics:

- **Binary/uniform costs** → HK01 algorithm
- **Sparse/rectangular** → SAP algorithm  
- **Large dense** → Auction algorithm (standard variant)
- **General case** → Jonker-Volgenant

For most users, `method = "auto"` (the default) provides good performance.

### Parallelization

**Note on parallelization**: Currently, only **`lap_solve_batch()`** supports parallel execution via the `n_threads` parameter. The individual LAP solvers (`lap_solve()`, `lap_solve_kbest()`) run sequentially. Future versions may add parallel support for single large problems.

```{r parallel-example, eval=FALSE}
# Parallel batch solving (supported)
lap_solve_batch(cost_list, n_threads = 4)

# Single problem (currently sequential)
lap_solve(cost)  # No parallelization yet
```

## Real-World Example: Employee Scheduling

Here's a practical example of using `couplr` to create a weekly work schedule:

```{r real-world}
set.seed(42)

# Generate employee preferences for shifts
schedule_data <- tibble(
  day = rep(c("Mon", "Tue", "Wed", "Thu", "Fri"), each = 12),
  employee = rep(1:4, times = 15),
  shift = rep(c("morning", "afternoon", "night"), each = 4, times = 5),
  preference_score = rnorm(60, mean = 5, sd = 2)
) |>
  mutate(
    # Some employees can't work certain shifts
    preference_score = case_when(
      employee == 1 & shift == "night" ~ NA_real_,
      employee == 2 & shift == "morning" ~ NA_real_,
      TRUE ~ preference_score
    ),
    # Create shift IDs within each day
    shift_id = as.integer(factor(shift, levels = c("morning", "afternoon", "night")))
  )

# Solve for optimal assignments per day (maximize preferences)
optimal_schedule <- schedule_data |>
  group_by(day) |>
  lap_solve(employee, shift_id, preference_score, maximize = TRUE)

# View first few assignments
head(optimal_schedule, 10)

# Summary statistics by day
optimal_schedule |>
  group_by(day) |>
  summarise(
    shifts_filled = n(),
    avg_preference = mean(cost, na.rm = TRUE),
    .groups = "drop"
  )
```

## Performance Considerations

`couplr` is designed for efficiency:

- **C++ backend**: Core algorithms implemented in optimized C++ using Rcpp
- **Automatic algorithm selection**: Chooses an efficient method for your problem
- **Batch processing**: Amortizes overhead when solving many problems
- **Parallel execution**: Distributes work across cores for large batches

For small problems (< 100×100), setup overhead dominates and all methods are fast. For large problems (> 1000×1000) or many problems, algorithm selection and parallelization become important.

| Problem Size | Typical Runtime | Recommendation |
|--------------|-----------------|----------------|
| < 100×100 | < 0.01s | Any method works |
| 100-500 | 0.01-0.1s | `method = "auto"` |
| 500-1000 | 0.1-1s | Consider `method = "jv"` |
| 1000-3000 | 1-30s | Use `method = "auction"` |
| > 3000 | > 30s | See `vignette("matching-workflows")` for blocking strategies |

## Common Pitfalls and Troubleshooting

### Problem: "All assignments have Inf cost"

**Cause**: Too many forbidden entries (NA/Inf) make the problem infeasible.

**Solution**: Check that a feasible solution exists. For rectangular problems with forbidden entries, ensure at least one valid assignment exists for each source.

```{r check-feasibility}
# Check feasibility before solving
cost_problematic <- matrix(c(
  1, NA, NA,
  NA, NA, NA,  # Row 2 has no valid targets!
  NA, 2, 3
), nrow = 3, byrow = TRUE)

# Check which rows have at least one finite value
feasible <- rowSums(is.finite(cost_problematic)) > 0
if (!all(feasible)) {
  cat("Infeasible rows:", which(!feasible), "\n")
}
```

### Problem: Unexpected assignments

**Cause**: Cost matrix orientation wrong (rows vs columns swapped).

**Solution**: Remember: rows = sources (nurses), columns = targets (shifts). The result shows source→target assignments.

```{r orientation-check}
# Verify orientation
cost_check <- matrix(c(1, 100, 100, 1), nrow = 2)
rownames(cost_check) <- c("Nurse_A", "Nurse_B")
colnames(cost_check) <- c("Shift_1", "Shift_2")
print(cost_check)

# Nurse_A should get Shift_1 (cost 1), Nurse_B should get Shift_2 (cost 1)
lap_solve(cost_check)
```

### Problem: Different results with different methods

**Cause**: Multiple optimal solutions may exist. Different algorithms may find different optima with the same total cost.

**Solution**: If you need deterministic results, use `method = "hungarian"` which has deterministic tie-breaking. Or verify that total costs match even if assignments differ.

### Problem: Slow performance on large problems

**Cause**: $O(n^3)$ complexity for exact algorithms.

**Solutions**:

- For n > 1000: Try `method = "auction"`
- For n > 3000: Use blocking via `vignette("matching-workflows")`
- For n > 5000: Consider greedy matching with `greedy_couples()`

```{r performance-tip, eval=FALSE}
# For large problems, auction algorithm is often faster
large_cost <- matrix(runif(1000000), nrow = 1000)
system.time(lap_solve(large_cost, method = "auction"))
```

### Problem: Memory errors

**Cause**: Cost matrix too large for available RAM. A 10,000×10,000 matrix requires ~800 MB.

**Solution**: Use blocking to divide the problem, or switch to greedy matching which doesn't require the full cost matrix in memory.

## Summary

This vignette walked through hospital staff scheduling to demonstrate couplr's core functionality:

1. **Basic solving**: Matrix and data frame inputs with `lap_solve()`
2. **Rectangular problems**: More shifts than nurses (or vice versa)
3. **Forbidden assignments**: Using NA/Inf for impossible pairings
4. **Maximization**: Optimizing preferences instead of minimizing costs
5. **Grouped data**: Solving multiple days at once with dplyr
6. **Batch solving**: Handling hundreds of independent problems
7. **K-best solutions**: Exploring alternatives to the optimal
8. **Algorithm selection**: Choosing the right solver for your problem

**What's Next?**

| If you want to... | Read... |
|-------------------|---------|
| Understand algorithm internals | `vignette("algorithms")` |
| Match observations in a study | `vignette("matching-workflows")` |
| Handle very large problems | `vignette("pixel-morphing")` for approximation strategies |

**Function reference**: `?lap_solve`, `?lap_solve_batch`, `?lap_solve_kbest`, `?hospital_staff`

**Source code**: [github.com/gcol33/couplr](https://github.com/gcol33/couplr)
